{
  "project": "WebRTC Peer-to-Peer Chat",
  "created": "2026-01-26T12:00:00.000Z",
  "projectType": "nuxt",
  "tasks": [
    {
      "name": "chat-invitation-schema",
      "description": "## Chat Invitation Database Schema\n\nCreate a Prisma schema for storing chat invitations between users.\n\n### Requirements\n- `ChatInvitation` model with fields:\n  - `id` - Auto-increment primary key\n  - `fromUserId` - Foreign key to User (inviter)\n  - `toUserId` - Foreign key to User (invitee)\n  - `status` - Enum: PENDING, ACCEPTED, DECLINED, EXPIRED\n  - `createdAt` - Timestamp\n  - `expiresAt` - Optional expiration timestamp\n- Relations to User model for both sender and receiver\n- Index on toUserId and status for efficient pending invitation queries\n\n### Files to Create\n- `server/database/schemas/chat-invitation.prisma`",
      "category": "data",
      "steps": [
        "Open server/database/schemas/chat-invitation.prisma",
        "Verify ChatInvitation model exists with id, fromUserId, toUserId, status, createdAt, expiresAt fields",
        "Verify status field uses an enum (PENDING, ACCEPTED, DECLINED, EXPIRED)",
        "Verify foreign key relations to User model for fromUser and toUser",
        "Run npm run db:generate to generate Prisma client",
        "Verify no errors during generation",
        "Run npm run db:push to push schema to database",
        "Verify schema is applied without errors"
      ],
      "passes": false
    },
    {
      "name": "chat-invitation-repository",
      "description": "## Chat Invitation Repository\n\nCreate a repository for CRUD operations on chat invitations.\n\n### Requirements\n- `createInvitation(fromUserId, toEmail)` - Create invitation by recipient email\n- `getInvitationById(id)` - Get single invitation with user details\n- `getPendingInvitationsForUser(userId)` - Get all pending invitations for a user\n- `updateInvitationStatus(id, status)` - Update invitation status\n- `deleteExpiredInvitations()` - Clean up expired invitations\n- Validate that target email exists before creating invitation\n- Prevent duplicate pending invitations between same users\n\n### Files to Create\n- `server/database/repositories/chatInvitationRepository.ts`",
      "category": "data",
      "steps": [
        "Open server/database/repositories/chatInvitationRepository.ts",
        "Verify createInvitation function accepts fromUserId and toEmail parameters",
        "Verify createInvitation validates the target email exists in the database",
        "Verify createInvitation prevents duplicate pending invitations",
        "Verify getPendingInvitationsForUser returns invitations with fromUser details",
        "Verify updateInvitationStatus correctly changes invitation status",
        "Run npm run typecheck to verify no TypeScript errors"
      ],
      "passes": false
    },
    {
      "name": "chat-invitation-api-endpoints",
      "description": "## Chat Invitation API Endpoints\n\nCreate REST API endpoints for managing chat invitations.\n\n### Endpoints\n1. `POST /api/chat/invitations` - Send invitation (body: { toEmail })\n2. `GET /api/chat/invitations` - Get pending invitations for current user\n3. `PUT /api/chat/invitations/[id]` - Accept/decline invitation (body: { status })\n4. `DELETE /api/chat/invitations/[id]` - Cancel invitation (sender only)\n\n### Requirements\n- All endpoints require authentication\n- Validate user cannot invite themselves\n- Return 404 if target email not found\n- Return 409 if pending invitation already exists\n- Include fromUser/toUser details in responses\n\n### Files to Create\n- `server/api/chat/invitations/index.post.ts`\n- `server/api/chat/invitations/index.get.ts`\n- `server/api/chat/invitations/[id].put.ts`\n- `server/api/chat/invitations/[id].delete.ts`",
      "category": "api",
      "steps": [
        "Start the development server with npm run dev",
        "Log in to get a valid auth token",
        "Send POST /api/chat/invitations without auth header, verify 401 response",
        "Send POST /api/chat/invitations with valid auth but missing toEmail, verify 400 response",
        "Send POST /api/chat/invitations with own email as toEmail, verify 400 response (cannot invite self)",
        "Send POST /api/chat/invitations with non-existent email, verify 404 response",
        "Send POST /api/chat/invitations with valid recipient email, verify 201 response with invitation data",
        "Send same POST again, verify 409 response (duplicate invitation)",
        "Send GET /api/chat/invitations, verify response includes the pending invitation",
        "Send PUT /api/chat/invitations/[id] with status ACCEPTED, verify 200 response",
        "Send DELETE /api/chat/invitations/[id] on own invitation, verify 200 response"
      ],
      "passes": false
    },
    {
      "name": "signaling-server-websocket",
      "description": "## WebSocket Signaling Server\n\nImplement a WebSocket server for WebRTC signaling (exchanging SDP offers/answers and ICE candidates).\n\n### Requirements\n- WebSocket endpoint at `/api/chat/signal` or use Nuxt's built-in WebSocket support\n- Handle message types:\n  - `join` - User joins with their userId\n  - `offer` - SDP offer from initiator\n  - `answer` - SDP answer from responder  \n  - `ice-candidate` - ICE candidate exchange\n  - `hang-up` - End the connection\n- Authenticate WebSocket connections using JWT\n- Route messages to specific users by email/userId\n- Handle disconnection cleanup\n\n### Implementation Notes\n- Use Nuxt's server WebSocket support or a library like `ws`\n- Store active connections mapped by userId\n- Validate that users have an accepted invitation before allowing signaling\n\n### Files to Create\n- `server/utils/signaling.ts` - WebSocket connection manager\n- `server/api/chat/signal.ts` - WebSocket endpoint handler",
      "category": "api",
      "steps": [
        "Open server/utils/signaling.ts and verify connection manager exists",
        "Verify signaling manager tracks connections by userId",
        "Verify signaling manager can route messages to specific users",
        "Open server/api/chat/signal.ts and verify WebSocket handler exists",
        "Start the development server with npm run dev",
        "Open browser DevTools and attempt WebSocket connection to /api/chat/signal",
        "Verify connection is rejected without valid JWT",
        "Log in and attempt WebSocket connection with auth",
        "Verify connection is established successfully",
        "Send a join message and verify server acknowledges"
      ],
      "passes": false
    },
    {
      "name": "webrtc-connection-composable",
      "description": "## WebRTC Connection Composable\n\nCreate a Vue composable for managing WebRTC peer connections.\n\n### Requirements\n- `useWebRTC(peerId)` composable that manages:\n  - RTCPeerConnection lifecycle\n  - Data channel creation for text messages\n  - Offer/answer SDP exchange via signaling server\n  - ICE candidate handling\n  - Connection state tracking\n- Reactive state:\n  - `connectionState` - 'disconnected' | 'connecting' | 'connected'\n  - `messages` - Array of sent/received messages\n- Methods:\n  - `connect()` - Initiate connection (create offer)\n  - `acceptConnection(offer)` - Accept incoming connection\n  - `sendMessage(text)` - Send text message via data channel\n  - `disconnect()` - Close connection\n\n### Files to Create\n- `client/features/chat/model/useWebRTC.ts`\n- `client/features/chat/model/types.ts`",
      "category": "integration",
      "steps": [
        "Open client/features/chat/model/useWebRTC.ts",
        "Verify composable creates RTCPeerConnection with STUN servers",
        "Verify composable creates data channel named 'chat'",
        "Verify connectionState reactive ref exists with correct initial value",
        "Verify messages reactive array exists",
        "Verify connect() method creates SDP offer and sends to signaling server",
        "Verify acceptConnection() method handles incoming offer and creates answer",
        "Verify sendMessage() method sends data through data channel",
        "Verify disconnect() method closes peer connection cleanly",
        "Run npm run typecheck to verify no TypeScript errors"
      ],
      "passes": false
    },
    {
      "name": "signaling-client-composable",
      "description": "## Signaling Client Composable\n\nCreate a Vue composable for WebSocket communication with the signaling server.\n\n### Requirements\n- `useSignaling()` composable that manages:\n  - WebSocket connection to signaling server\n  - Authentication with JWT on connect\n  - Message sending/receiving\n  - Auto-reconnection on disconnect\n- Reactive state:\n  - `isConnected` - WebSocket connection status\n  - `pendingInvitations` - Incoming chat invitations\n- Methods:\n  - `connect()` - Establish WebSocket connection\n  - `sendOffer(toUserId, sdp)` - Send SDP offer\n  - `sendAnswer(toUserId, sdp)` - Send SDP answer\n  - `sendIceCandidate(toUserId, candidate)` - Send ICE candidate\n  - `disconnect()` - Close WebSocket\n- Events (via callback or provide/inject):\n  - `onInvitation` - New chat invitation received\n  - `onOffer` - SDP offer received\n  - `onAnswer` - SDP answer received\n  - `onIceCandidate` - ICE candidate received\n\n### Files to Create\n- `client/features/chat/model/useSignaling.ts`",
      "category": "integration",
      "steps": [
        "Open client/features/chat/model/useSignaling.ts",
        "Verify composable creates WebSocket connection with JWT auth",
        "Verify isConnected reactive ref updates on connect/disconnect",
        "Verify sendOffer method sends properly formatted message",
        "Verify sendAnswer method sends properly formatted message",
        "Verify sendIceCandidate method sends properly formatted message",
        "Verify incoming message handlers parse and route to callbacks",
        "Verify auto-reconnection logic exists",
        "Run npm run typecheck to verify no TypeScript errors"
      ],
      "passes": false
    },
    {
      "name": "chat-pinia-store",
      "description": "## Chat Pinia Store\n\nCreate a Pinia store for managing chat state across the application.\n\n### Requirements\n- Store state:\n  - `activeChat` - Current chat partner info (userId, email) or null\n  - `messages` - Array of chat messages with timestamps\n  - `pendingInvitations` - Incoming invitations\n  - `connectionStatus` - 'idle' | 'connecting' | 'connected' | 'error'\n  - `isChatOpen` - Whether chat panel is visible\n- Actions:\n  - `sendInvitation(toEmail)` - Send chat invitation via API\n  - `acceptInvitation(invitationId)` - Accept and initiate connection\n  - `declineInvitation(invitationId)` - Decline invitation\n  - `sendMessage(text)` - Send message through WebRTC\n  - `disconnect()` - End current chat session\n  - `fetchPendingInvitations()` - Load invitations from API\n\n### Files to Create\n- `client/shared/stores/chat.ts`\n- Update `client/shared/stores/index.ts` to export new store",
      "category": "data",
      "steps": [
        "Open client/shared/stores/chat.ts",
        "Verify store has activeChat, messages, pendingInvitations, connectionStatus, isChatOpen state",
        "Verify sendInvitation action calls POST /api/chat/invitations",
        "Verify acceptInvitation action calls PUT API and initiates WebRTC connection",
        "Verify declineInvitation action calls PUT API with DECLINED status",
        "Verify sendMessage action sends through WebRTC data channel",
        "Verify disconnect action cleans up WebRTC and resets state",
        "Open client/shared/stores/index.ts and verify useChatStore is exported",
        "Run npm run typecheck to verify no TypeScript errors"
      ],
      "passes": false
    },
    {
      "name": "chat-widget-container",
      "description": "## Chat Widget Container\n\nCreate the main chat widget that appears in the bottom-right corner of the app.\n\n### Requirements\n- Positioned fixed bottom-right with appropriate z-index\n- Collapsed state: Small button/bubble showing notification badge for pending invitations\n- Expanded state: Chat panel with header, messages area, and input\n- Toggle open/close on click\n- Only visible when user is authenticated\n- Smooth open/close animation\n\n### Layout\n- Header: Chat partner email/name, close button, disconnect button\n- Body: Messages list (scrollable)\n- Footer: Message input and send button\n\n### Files to Create\n- `client/widgets/chat/index.ts`\n- `client/widgets/chat/ui/ChatWidget.vue`",
      "category": "ui",
      "steps": [
        "Start the development server with npm run dev",
        "Log in to the application",
        "Verify chat bubble/button appears in bottom-right corner",
        "Verify chat bubble is NOT visible when logged out",
        "Click the chat bubble",
        "Verify chat panel expands with smooth animation",
        "Verify panel has header, messages area, and input field",
        "Click close button or outside panel",
        "Verify panel collapses with smooth animation",
        "Open browser DevTools and verify no console errors"
      ],
      "passes": false
    },
    {
      "name": "join-room-ui",
      "description": "## Join Room Interface\n\nCreate the UI for initiating a chat by entering another user's email.\n\n### Requirements\n- \"Join Room\" or \"Start Chat\" button visible when no active chat\n- Clicking opens modal/form with email input\n- Email validation (format check)\n- Loading state while sending invitation\n- Error handling:\n  - User not found message\n  - Cannot invite yourself message\n  - Already pending invitation message\n- Success state: \"Waiting for [email] to accept...\"\n\n### Files to Create/Modify\n- `client/widgets/chat/ui/JoinRoomForm.vue`\n- Integrate into ChatWidget.vue",
      "category": "ui",
      "steps": [
        "Start the development server with npm run dev",
        "Log in and open the chat widget",
        "Verify 'Join Room' or 'Start Chat' button is visible",
        "Click the Join Room button",
        "Verify email input modal/form appears",
        "Enter invalid email format and try to submit",
        "Verify validation error message appears",
        "Enter your own email and submit",
        "Verify 'cannot invite yourself' error message",
        "Enter a non-existent email and submit",
        "Verify 'user not found' error message",
        "Enter a valid existing user email and submit",
        "Verify loading state appears during request",
        "Verify success message shows 'Waiting for [email] to accept...'"
      ],
      "passes": false
    },
    {
      "name": "invitation-notification-ui",
      "description": "## Invitation Notification UI\n\nCreate UI for receiving and responding to chat invitations.\n\n### Requirements\n- Notification badge on chat bubble showing pending invitation count\n- When chat panel opens, show list of pending invitations\n- Each invitation shows:\n  - Sender email\n  - Accept button\n  - Decline button\n  - Time received\n- Real-time updates via WebSocket (new invitations appear immediately)\n- Accept triggers WebRTC connection flow\n\n### Files to Create/Modify\n- `client/widgets/chat/ui/InvitationList.vue`\n- Integrate into ChatWidget.vue",
      "category": "ui",
      "steps": [
        "Start the development server with npm run dev",
        "Log in as user1 and send invitation to user2's email",
        "Log in as user2 in another browser/incognito",
        "Verify notification badge appears on user2's chat bubble",
        "Open user2's chat panel",
        "Verify pending invitation from user1 is displayed",
        "Verify invitation shows sender email and Accept/Decline buttons",
        "Click Decline on an invitation",
        "Verify invitation is removed from list",
        "Send another invitation from user1",
        "Verify user2 sees new invitation appear in real-time (without refresh)"
      ],
      "passes": false
    },
    {
      "name": "connection-status-ui",
      "description": "## Connection Status UI\n\nCreate UI feedback for the WebRTC connection process.\n\n### Requirements\n- When user1 sends invitation: Show \"Waiting for [email] to accept...\"\n- When user2 accepts: Both users see \"Connecting to chat...\"\n- During ICE gathering: Show connecting spinner/animation\n- On successful connection: Transition to chat interface\n- On connection failure: Show error with retry option\n- Connection state indicator in chat header (green dot = connected)\n\n### Files to Create/Modify\n- `client/widgets/chat/ui/ConnectionStatus.vue`\n- Integrate into ChatWidget.vue",
      "category": "ui",
      "steps": [
        "Start the development server with npm run dev",
        "Log in as user1 and send invitation to user2",
        "Verify user1 sees 'Waiting for [email] to accept...' message",
        "Log in as user2 and accept the invitation",
        "Verify both users see 'Connecting to chat...' with spinner",
        "Wait for WebRTC connection to establish",
        "Verify connection status changes to show connected state",
        "Verify green indicator appears in chat header",
        "Simulate connection failure (disable network briefly)",
        "Verify error state appears with retry option"
      ],
      "passes": false
    },
    {
      "name": "chat-messages-ui",
      "description": "## Chat Messages Interface\n\nCreate the UI for displaying and sending chat messages.\n\n### Requirements\n- Message list:\n  - Sent messages aligned right (different bg color)\n  - Received messages aligned left\n  - Timestamps on each message\n  - Auto-scroll to bottom on new messages\n- Message input:\n  - Text input with send button\n  - Send on Enter key\n  - Shift+Enter for newline\n  - Disable input when not connected\n- Empty state when no messages yet\n\n### Files to Create/Modify\n- `client/widgets/chat/ui/MessageList.vue`\n- `client/widgets/chat/ui/MessageInput.vue`\n- Integrate into ChatWidget.vue",
      "category": "ui",
      "steps": [
        "Start the development server with npm run dev",
        "Log in as user1 and user2, establish WebRTC connection",
        "Verify chat interface shows empty state initially",
        "Verify message input is enabled when connected",
        "Type a message and click send button",
        "Verify message appears in user1's message list (right-aligned)",
        "Verify same message appears in user2's message list (left-aligned)",
        "Verify timestamp is shown on the message",
        "Send multiple messages from both users",
        "Verify messages auto-scroll to show newest",
        "Press Enter to send a message, verify it sends",
        "Press Shift+Enter, verify it creates newline instead of sending"
      ],
      "passes": false
    },
    {
      "name": "chat-widget-integration",
      "description": "## Integrate Chat Widget into App Layout\n\nAdd the chat widget to the main application layout so it appears on all pages.\n\n### Requirements\n- Add ChatWidget to default layout\n- Only render when user is authenticated\n- Ensure proper z-index above other content\n- Chat state persists across page navigation\n- Handle logout (disconnect and hide chat)\n\n### Files to Modify\n- `client/app/layouts/default.vue`",
      "category": "integration",
      "steps": [
        "Start the development server with npm run dev",
        "Navigate to login page, verify chat widget is NOT visible",
        "Log in to the application",
        "Verify chat widget appears in bottom-right corner",
        "Navigate to different pages in the app",
        "Verify chat widget remains visible and state persists",
        "Open chat and start a conversation",
        "Navigate to another page",
        "Verify chat panel state (open/closed) and messages persist",
        "Log out of the application",
        "Verify chat widget disappears and connection is closed"
      ],
      "passes": false
    },
    {
      "name": "chat-feature-public-api",
      "description": "## Chat Feature Public API\n\nCreate proper FSD public API exports for the chat feature.\n\n### Requirements\n- Export composables from feature index\n- Export types from feature index\n- Follow FSD naming conventions\n- Ensure all internal modules are not directly importable\n\n### Files to Create\n- `client/features/chat/index.ts`\n\n### Exports\n- `useChat` - Main composable for chat functionality\n- Types: `ChatMessage`, `ChatInvitation`, etc.",
      "category": "config",
      "steps": [
        "Open client/features/chat/index.ts",
        "Verify useChat or relevant composables are exported",
        "Verify ChatMessage and ChatInvitation types are exported",
        "Verify internal implementation files are not exported directly",
        "Try importing from @features/chat in a test file",
        "Verify imports work correctly",
        "Run npm run typecheck to verify no TypeScript errors",
        "Run npm run lint to verify FSD structure compliance"
      ],
      "passes": false
    },
    {
      "name": "e2e-chat-flow-test",
      "description": "## End-to-End Chat Flow Manual Test\n\nComprehensive manual testing of the complete chat feature.\n\n### Test Scenario\nTwo users establishing a WebRTC chat connection and exchanging messages.\n\n### Prerequisites\n- Two user accounts in the database\n- Two browser windows (or browser + incognito)\n\n### Test Steps\nComplete flow from invitation to messaging.",
      "category": "testing",
      "steps": [
        "Start the development server with npm run dev",
        "Open two browser windows side by side",
        "Log in as user1 in window 1, log in as user2 in window 2",
        "In window 1, click the chat bubble to open chat panel",
        "Click 'Join Room' and enter user2's email",
        "Submit and verify 'Waiting for user2 to accept...' appears",
        "In window 2, verify notification badge appears on chat bubble",
        "Open chat panel in window 2",
        "Verify invitation from user1 is shown",
        "Click Accept on the invitation",
        "Verify both windows show 'Connecting to chat...'",
        "Wait for WebRTC connection to establish",
        "Verify both windows show connected state",
        "In window 1, type 'Hello from user1' and send",
        "Verify message appears in both windows",
        "In window 2, type 'Hello from user2' and send",
        "Verify message appears in both windows",
        "Click disconnect in either window",
        "Verify both windows return to disconnected state"
      ],
      "passes": false
    }
  ]
}
