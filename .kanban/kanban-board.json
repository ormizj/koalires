{
  "project": "WebRTC Peer-to-Peer Chat via Email",
  "created": "2026-01-22T10:00:00Z",
  "projectType": "nuxt-fsd",
  "tasks": [
    {
      "name": "signaling-server-schema",
      "description": "## Signaling Server Schema\n\nCreate Prisma schema to store signaling data for WebRTC peer connections.\n\n### Requirements\n- Create `SignalSession` model to track active peer sessions\n- Store initiator email, target email, session ID\n- Store WebRTC signaling data (SDP offers/answers, ICE candidates)\n- Include session status (waiting, connected, disconnected)\n- Add timestamps for session management\n- Add cleanup mechanism for stale sessions",
      "category": "data",
      "steps": [
        "Open server/database/schemas/ directory",
        "Create new signal.prisma file",
        "Define SignalSession model with id, sessionId (unique), initiatorEmail, targetEmail, status enum (waiting/connected/disconnected), offer JSON, answer JSON, iceCandidates JSON array, createdAt, updatedAt fields",
        "Add relations to User model via email",
        "Run npm run db:generate to generate Prisma client",
        "Run npm run db:push to apply schema changes",
        "Verify table created in database with npm run db:studio"
      ],
      "passes": false
    },
    {
      "name": "signaling-repository",
      "description": "## Signaling Repository Layer\n\nCreate repository functions for WebRTC signaling CRUD operations.\n\n### Requirements\n- Create signaling repository in server/database/repositories/\n- Implement createSession function\n- Implement findSessionByEmails (find session where both users match)\n- Implement updateSessionOffer (store SDP offer)\n- Implement updateSessionAnswer (store SDP answer)\n- Implement addIceCandidate function\n- Implement getIceCandidates function\n- Implement updateSessionStatus function\n- Implement deleteSession function\n- Implement cleanupStaleSessions utility",
      "category": "data",
      "steps": [
        "Create server/database/repositories/signal.repository.ts",
        "Import Prisma client from composables",
        "Implement createSession(initiatorEmail, targetEmail) that creates a new session with unique sessionId",
        "Implement findSessionByEmails(email1, email2) that finds existing session between two users",
        "Implement findSessionBySessionId(sessionId) to get session by ID",
        "Implement updateSessionOffer(sessionId, offer) to store SDP offer",
        "Implement updateSessionAnswer(sessionId, answer) to store SDP answer",
        "Implement addIceCandidate(sessionId, candidate, fromEmail) to add ICE candidate",
        "Implement getIceCandidates(sessionId, forEmail) to get candidates for a user",
        "Implement updateSessionStatus(sessionId, status) to change session status",
        "Implement deleteSession(sessionId) to remove session",
        "Implement cleanupStaleSessions() to remove sessions older than 1 hour",
        "Export all functions from repository"
      ],
      "passes": false
    },
    {
      "name": "signaling-api-endpoints",
      "description": "## WebRTC Signaling API Endpoints\n\nCreate API endpoints for WebRTC signaling exchange.\n\n### Endpoints\n- POST /api/signaling/initiate - Start a connection attempt with target email\n- POST /api/signaling/offer - Store SDP offer\n- POST /api/signaling/answer - Store SDP answer\n- POST /api/signaling/ice-candidate - Add ICE candidate\n- GET /api/signaling/session/[sessionId] - Get session state and signaling data\n- GET /api/signaling/pending - Check for incoming connection requests\n- DELETE /api/signaling/session/[sessionId] - End session",
      "category": "api",
      "steps": [
        "Create server/api/signaling/ directory",
        "Create initiate.post.ts for starting connection attempts",
        "Send POST /api/signaling/initiate with targetEmail",
        "Verify session created or existing session returned",
        "Create offer.post.ts for storing SDP offers",
        "Send POST /api/signaling/offer with sessionId and sdp",
        "Verify offer stored in session",
        "Create answer.post.ts for storing SDP answers",
        "Send POST /api/signaling/answer with sessionId and sdp",
        "Verify answer stored in session",
        "Create ice-candidate.post.ts for ICE candidates",
        "Send POST /api/signaling/ice-candidate with sessionId and candidate",
        "Verify candidate added to session",
        "Create session/[sessionId].get.ts to get session state",
        "Send GET /api/signaling/session/abc123 and verify session data returned",
        "Create pending.get.ts to check for incoming requests",
        "Send GET /api/signaling/pending and verify pending sessions listed",
        "Create session/[sessionId].delete.ts to end session",
        "Send DELETE /api/signaling/session/abc123 and verify session removed"
      ],
      "passes": false
    },
    {
      "name": "chat-feature-composable",
      "description": "## WebRTC Chat Feature Composable\n\nCreate a composable for managing WebRTC peer connections and chat state.\n\n### Requirements\n- Create useWebRTCChat composable in client/features/chat/\n- Manage RTCPeerConnection lifecycle\n- Handle RTCDataChannel for text messages\n- Implement initiateConnection(targetEmail)\n- Implement acceptConnection(sessionId)\n- Implement sendMessage(text)\n- Handle ICE candidate exchange\n- Manage connection state (disconnected, connecting, connected)\n- Store chat message history\n- Handle connection errors gracefully",
      "category": "ui",
      "steps": [
        "Create client/features/chat/ directory structure",
        "Create client/features/chat/model/useWebRTCChat.ts composable",
        "Define reactive state: connectionState, messages, error, targetEmail, sessionId",
        "Implement createPeerConnection() using RTCPeerConnection with STUN servers",
        "Implement setupDataChannel() for RTCDataChannel messaging",
        "Implement initiateConnection(targetEmail) that creates offer and posts to signaling API",
        "Implement pollForAnswer() that polls signaling API for SDP answer",
        "Implement acceptConnection(sessionId) that creates answer for incoming connection",
        "Implement handleIceCandidate() to send ICE candidates to signaling API",
        "Implement receiveIceCandidates() to poll and apply remote ICE candidates",
        "Implement sendMessage(text) using RTCDataChannel",
        "Implement disconnect() to close connection and cleanup",
        "Add onmessage handler to store received messages",
        "Add connection state change handlers",
        "Create client/features/chat/index.ts exporting useWebRTCChat",
        "Test composable initializes without errors"
      ],
      "passes": false
    },
    {
      "name": "chat-widget-component",
      "description": "## Chat Widget Component\n\nCreate the chat widget UI that appears in the bottom right corner.\n\n### Requirements\n- Create ChatWidget component in client/widgets/chat/ui/\n- Collapsed state: small chat bubble/icon in bottom right\n- Expanded state: chat window with join room input and messages\n- Show 'Join Room' button to start connection\n- Email input field for target user\n- 'Connecting...' state while establishing WebRTC connection\n- Message list showing chat history\n- Message input for sending new messages\n- Connection status indicator\n- Minimize/close buttons",
      "category": "ui",
      "steps": [
        "Create client/widgets/chat/ directory structure",
        "Create client/widgets/chat/ui/ChatWidget.vue component",
        "Define reactive state: isExpanded, targetEmail, messageInput",
        "Import useWebRTCChat composable",
        "Add collapsed view: small circular button in bottom-right with chat icon",
        "Add click handler to toggle isExpanded",
        "Add expanded view: fixed position chat window (bottom-right, 350x500px)",
        "Add header with title and minimize/close buttons",
        "Add 'Join Room' section with email input and connect button",
        "Add 'Connecting to chat...' message when connectionState is 'connecting'",
        "Add message list container with scrollable messages",
        "Display each message with sender indicator and text",
        "Add message input at bottom with send button",
        "Wire up connect button to initiateConnection(targetEmail)",
        "Wire up send button to sendMessage(messageInput)",
        "Wire up close to disconnect()",
        "Style using Tailwind with dark mode support",
        "Create client/widgets/chat/index.ts exporting ChatWidget"
      ],
      "passes": false
    },
    {
      "name": "chat-widget-layout-integration",
      "description": "## Integrate Chat Widget in Layout\n\nAdd the chat widget to the default layout so it appears on all authenticated pages.\n\n### Requirements\n- Import ChatWidget into default layout\n- Only show when user is authenticated\n- Position fixed in bottom-right corner\n- Ensure proper z-index layering",
      "category": "ui",
      "steps": [
        "Open client/app/layouts/default.vue",
        "Import ChatWidget from ~/widgets/chat",
        "Add ChatWidget component after main slot",
        "Wrap ChatWidget in v-if=\"isAuthenticated\"",
        "Start development server with npm run dev",
        "Log in to the application",
        "Navigate to any page (e.g., /files)",
        "Verify chat bubble appears in bottom-right corner",
        "Click chat bubble to expand",
        "Verify chat window opens with Join Room interface",
        "Log out and verify chat bubble disappears"
      ],
      "passes": false
    },
    {
      "name": "pending-connection-notification",
      "description": "## Incoming Connection Notification\n\nImplement polling for pending connection requests and show notification.\n\n### Requirements\n- Poll /api/signaling/pending periodically when user is logged in\n- When pending request found, show notification in chat widget\n- Show who is trying to connect (their email)\n- Provide Accept/Decline buttons\n- Accept triggers acceptConnection flow\n- Decline removes the session",
      "category": "ui",
      "steps": [
        "Open client/features/chat/model/useWebRTCChat.ts",
        "Add pendingRequest ref to store incoming request data",
        "Add startPollingForPending() function using setInterval",
        "Poll GET /api/signaling/pending every 3 seconds",
        "When pending session found, set pendingRequest with session data",
        "Add stopPollingForPending() to clear interval",
        "Add acceptPendingRequest(sessionId) that calls acceptConnection",
        "Add declinePendingRequest(sessionId) that deletes the session",
        "Open client/widgets/chat/ui/ChatWidget.vue",
        "Add section showing pending request notification",
        "Display 'User [email] wants to connect' message",
        "Add Accept and Decline buttons",
        "Wire Accept to acceptPendingRequest",
        "Wire Decline to declinePendingRequest",
        "Start polling when widget mounts (if authenticated)",
        "Stop polling on unmount",
        "Test: User1 initiates connection to User2",
        "Test: User2 sees pending notification with User1's email",
        "Test: User2 clicks Accept and connection proceeds"
      ],
      "passes": false
    },
    {
      "name": "connection-flow-states",
      "description": "## Connection Flow State Management\n\nImplement proper state transitions and UI feedback during connection flow.\n\n### States\n- idle: Initial state, show Join Room UI\n- connecting: After initiating, waiting for peer\n- pending-accept: Has incoming request to accept\n- signaling: Exchanging SDP/ICE candidates\n- connected: WebRTC DataChannel open, ready to chat\n- disconnected: Connection ended or failed\n- error: Something went wrong",
      "category": "ui",
      "steps": [
        "Open client/features/chat/model/useWebRTCChat.ts",
        "Define connectionState type with all states",
        "Update state transitions in initiateConnection flow",
        "Set 'connecting' immediately after initiate API call",
        "Set 'signaling' when offer/answer exchange begins",
        "Set 'connected' when DataChannel opens",
        "Set 'error' on any caught exceptions",
        "Add errorMessage ref to store error details",
        "Open client/widgets/chat/ui/ChatWidget.vue",
        "Conditionally render Join Room UI when state is 'idle'",
        "Show 'Connecting to [email]...' spinner when 'connecting'",
        "Show 'Incoming request from [email]' when 'pending-accept'",
        "Show 'Establishing connection...' when 'signaling'",
        "Show full chat interface when 'connected'",
        "Show 'Disconnected' message with reconnect option when 'disconnected'",
        "Show error message with retry option when 'error'",
        "Test each state transition displays correct UI"
      ],
      "passes": false
    },
    {
      "name": "message-display-styling",
      "description": "## Message Display and Styling\n\nImplement proper message display with sender differentiation and styling.\n\n### Requirements\n- Messages from current user aligned right, colored differently\n- Messages from peer aligned left\n- Show timestamp for each message\n- Auto-scroll to newest message\n- Empty state when no messages yet\n- Proper text wrapping for long messages",
      "category": "ui",
      "steps": [
        "Open client/features/chat/model/useWebRTCChat.ts",
        "Ensure message objects have: id, text, fromSelf (boolean), timestamp",
        "Add message to array when sent (fromSelf: true)",
        "Add message to array when received (fromSelf: false)",
        "Open client/widgets/chat/ui/ChatWidget.vue",
        "Create message bubble component/styling",
        "Apply right alignment and blue/primary color for own messages",
        "Apply left alignment and gray/neutral color for peer messages",
        "Format and display timestamp below each message",
        "Add ref to message container element",
        "Add watch on messages array to scroll to bottom",
        "Implement scrollToBottom() using scrollTop = scrollHeight",
        "Add empty state message 'No messages yet'",
        "Apply max-width and word-wrap to message bubbles",
        "Test sending multiple messages, verify alignment",
        "Test receiving messages, verify different styling",
        "Test long messages wrap properly",
        "Test auto-scroll works on new messages"
      ],
      "passes": false
    },
    {
      "name": "connection-cleanup-handling",
      "description": "## Connection Cleanup and Error Handling\n\nImplement proper cleanup on disconnect and error recovery.\n\n### Requirements\n- Clean up RTCPeerConnection on disconnect\n- Clean up RTCDataChannel on disconnect\n- Delete signaling session on disconnect\n- Stop polling intervals on disconnect\n- Handle page unload/navigation\n- Provide reconnect functionality\n- Handle network disconnection gracefully",
      "category": "ui",
      "steps": [
        "Open client/features/chat/model/useWebRTCChat.ts",
        "Implement disconnect() that closes DataChannel",
        "Close RTCPeerConnection in disconnect()",
        "Call DELETE /api/signaling/session/[sessionId] in disconnect()",
        "Clear all polling intervals in disconnect()",
        "Reset state to 'idle' after cleanup",
        "Add onbeforeunload handler to call disconnect",
        "Add onConnectionStateChange handler to detect failures",
        "Set state to 'disconnected' when ICE connection fails",
        "Implement reconnect() that resets state and allows new connection",
        "Open client/widgets/chat/ui/ChatWidget.vue",
        "Add disconnect button visible when connected",
        "Add reconnect button visible when disconnected or error",
        "Wire buttons to respective functions",
        "Use onUnmounted to call disconnect",
        "Test: Connect two users, one disconnects, verify cleanup",
        "Test: Close browser tab, verify session cleaned up",
        "Test: Reconnect after disconnect works properly"
      ],
      "passes": false
    },
    {
      "name": "validate-user-exists",
      "description": "## Validate Target User Exists\n\nAdd validation to ensure the target email exists before initiating connection.\n\n### Requirements\n- Check if email exists in database before creating session\n- Return appropriate error if user not found\n- Prevent connecting to oneself\n- Show validation error in UI",
      "category": "api",
      "steps": [
        "Open server/api/signaling/initiate.post.ts",
        "Import user repository",
        "Get authenticated user's email",
        "Check if targetEmail equals current user's email",
        "Return 400 error if trying to connect to self",
        "Query database for user with targetEmail",
        "Return 404 error if target user not found",
        "Continue with session creation if user exists",
        "Open client/features/chat/model/useWebRTCChat.ts",
        "Handle API error responses in initiateConnection",
        "Set appropriate error message for each error type",
        "Open client/widgets/chat/ui/ChatWidget.vue",
        "Display error message below email input",
        "Clear error when user starts typing new email",
        "Test: Enter non-existent email, verify error shown",
        "Test: Enter own email, verify 'cannot connect to yourself' error",
        "Test: Enter valid email, verify no error and connection starts"
      ],
      "passes": false
    },
    {
      "name": "ice-server-configuration",
      "description": "## ICE Server Configuration\n\nConfigure STUN/TURN servers for NAT traversal.\n\n### Requirements\n- Add STUN server configuration (Google's public servers)\n- Add environment variable support for custom TURN servers\n- Configure ICE candidate gathering settings\n- Handle ICE gathering complete event",
      "category": "config",
      "steps": [
        "Open client/features/chat/model/useWebRTCChat.ts",
        "Create iceServers configuration array",
        "Add Google STUN servers: stun:stun.l.google.com:19302",
        "Add backup STUN server: stun:stun1.l.google.com:19302",
        "Use runtimeConfig to optionally add TURN servers",
        "Pass iceServers config to RTCPeerConnection constructor",
        "Add onicegatheringstatechange event handler",
        "Log ICE gathering state changes for debugging",
        "Open nuxt.config.ts",
        "Add public.turnServer to runtimeConfig (optional)",
        "Open .env.example and document TURN server config",
        "Test: Connect two users on same network, verify connection works",
        "Test: Check browser console for ICE gathering logs"
      ],
      "passes": false
    }
  ]
}
