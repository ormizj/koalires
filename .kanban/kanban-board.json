{
  "project": "WebRTC Peer-to-Peer Chat",
  "created": "2026-01-25T12:00:00.000Z",
  "projectType": "nuxt",
  "tasks": [
    {
      "name": "chat-invitation-schema",
      "description": "## Chat Invitation Database Schema\n\nCreate Prisma schema for storing chat invitations between users.\n\n### Requirements\n- Store sender user ID, receiver user ID\n- Store invitation status (pending, accepted, rejected, expired)\n- Store creation timestamp and expiration time\n- Store signaling data for WebRTC connection setup\n- Create relations to User model\n\n### Implementation Notes\n- Add new file `server/database/schemas/chat-invitation.prisma`\n- Use similar patterns as existing Prisma schemas in the project\n- Invitation should expire after a reasonable timeout (e.g., 5 minutes)",
      "category": "data",
      "steps": [
        "Open server/database/schemas/chat-invitation.prisma",
        "Verify the ChatInvitation model has id, senderId, receiverId, status fields",
        "Verify status is an enum with values: PENDING, ACCEPTED, REJECTED, EXPIRED",
        "Verify createdAt and expiresAt timestamp fields exist",
        "Verify signalingData field exists for WebRTC offer/answer storage",
        "Verify relations to User model are defined correctly",
        "Run npm run db:generate to generate Prisma client",
        "Verify command completes without errors"
      ],
      "passes": false
    },
    {
      "name": "chat-invitation-repository",
      "description": "## Chat Invitation Repository\n\nCreate repository for CRUD operations on chat invitations.\n\n### Requirements\n- Create invitation (sender creates invite for receiver by email)\n- Find pending invitations for a user\n- Accept/reject invitation\n- Update signaling data\n- Auto-expire old invitations\n- Find user by email (for invitation lookup)\n\n### Implementation Notes\n- Add new file `server/database/repositories/chatInvitation.ts`\n- Follow existing repository patterns in the project\n- Use Prisma client from server composables",
      "category": "data",
      "steps": [
        "Open server/database/repositories/chatInvitation.ts",
        "Verify createInvitation function exists and accepts senderUserId and receiverEmail",
        "Verify findPendingInvitationsForUser function exists",
        "Verify acceptInvitation and rejectInvitation functions exist",
        "Verify updateSignalingData function exists for WebRTC offer/answer",
        "Verify the repository uses prisma client from composables",
        "Run npm run typecheck to verify TypeScript types are correct"
      ],
      "passes": false
    },
    {
      "name": "chat-signaling-api-endpoints",
      "description": "## Chat Signaling API Endpoints\n\nCreate API endpoints for WebRTC signaling and chat invitation management.\n\n### Endpoints\n- `POST /api/chat/invite` - Create invitation to chat with another user by email\n- `GET /api/chat/invitations` - Get pending invitations for current user\n- `POST /api/chat/invite/[id]/accept` - Accept a chat invitation\n- `POST /api/chat/invite/[id]/reject` - Reject a chat invitation\n- `POST /api/chat/signal` - Exchange WebRTC signaling data (offer/answer/ICE candidates)\n- `GET /api/chat/signal/[invitationId]` - Poll for signaling data updates\n\n### Implementation Notes\n- All endpoints require authentication\n- Use existing auth middleware pattern\n- Follow existing API patterns in server/api/\n- Signaling endpoint handles SDP offers, answers, and ICE candidates",
      "category": "api",
      "steps": [
        "Start the development server with npm run dev",
        "Open a terminal or API testing tool",
        "Send POST to /api/chat/invite without auth header",
        "Verify response status is 401 Unauthorized",
        "Log in to get a valid auth token",
        "Send POST to /api/chat/invite with body {email: 'test@example.com'} and auth header",
        "Verify response indicates invitation created or appropriate error",
        "Send GET to /api/chat/invitations with auth header",
        "Verify response returns array of pending invitations",
        "Verify POST /api/chat/signal endpoint accepts signaling data"
      ],
      "passes": false
    },
    {
      "name": "chat-store",
      "description": "## Chat Pinia Store\n\nCreate Pinia store for managing chat state on the client.\n\n### State\n- currentPeerEmail: string | null - Email of connected peer\n- connectionStatus: 'disconnected' | 'connecting' | 'connected'\n- pendingInvitations: ChatInvitation[]\n- messages: ChatMessage[]\n- isChatOpen: boolean\n\n### Actions\n- sendInvitation(email: string) - Send chat invite\n- acceptInvitation(id: number) - Accept incoming invite\n- rejectInvitation(id: number) - Reject incoming invite\n- fetchInvitations() - Fetch pending invites\n- addMessage(message: ChatMessage) - Add message to list\n- clearChat() - Clear messages and disconnect\n\n### Implementation Notes\n- Add new file `client/shared/stores/chat.ts`\n- Export from `client/shared/stores/index.ts`\n- Follow existing store patterns (useAuthStore)",
      "category": "data",
      "steps": [
        "Open client/shared/stores/chat.ts",
        "Verify useChatStore is defined with defineStore",
        "Verify state includes connectionStatus, pendingInvitations, messages, isChatOpen",
        "Verify sendInvitation action calls POST /api/chat/invite",
        "Verify fetchInvitations action calls GET /api/chat/invitations",
        "Verify acceptInvitation and rejectInvitation actions exist",
        "Open client/shared/stores/index.ts",
        "Verify useChatStore is exported",
        "Run npm run typecheck to verify TypeScript types"
      ],
      "passes": false
    },
    {
      "name": "webrtc-composable",
      "description": "## WebRTC Connection Composable\n\nCreate composable for managing WebRTC peer connections.\n\n### Features\n- Create RTCPeerConnection with STUN/TURN servers\n- Create and handle SDP offers/answers\n- Handle ICE candidate exchange\n- Create data channel for text messages\n- Connection state management\n- Cleanup on disconnect\n\n### Implementation Notes\n- Add new file `client/features/chat/model/useWebRTC.ts`\n- Use public STUN servers (stun:stun.l.google.com:19302)\n- Emit events for connection state changes\n- Integrate with signaling API for offer/answer exchange",
      "category": "integration",
      "steps": [
        "Open client/features/chat/model/useWebRTC.ts",
        "Verify useWebRTC composable is exported",
        "Verify RTCPeerConnection is created with ICE servers config",
        "Verify createOffer function exists and returns SDP offer",
        "Verify handleAnswer function exists to process SDP answer",
        "Verify ICE candidate handling is implemented",
        "Verify data channel is created for text messaging",
        "Verify onMessage callback is called when messages arrive",
        "Verify sendMessage function sends data through data channel",
        "Verify cleanup/close function properly closes connection"
      ],
      "passes": false
    },
    {
      "name": "chat-feature-composable",
      "description": "## Chat Feature Composable\n\nCreate main composable that orchestrates chat invitation flow and messaging.\n\n### Features\n- useChat() composable combining store and WebRTC\n- Start chat flow (enter email -> send invite -> wait for connection)\n- Handle incoming invitations\n- Poll for signaling data during connection setup\n- Send and receive messages\n- Connection status tracking\n\n### Implementation Notes\n- Add new file `client/features/chat/model/useChat.ts`\n- Coordinate between useChatStore and useWebRTC\n- Handle the full P2P connection lifecycle\n- Add to feature index.ts for export",
      "category": "integration",
      "steps": [
        "Open client/features/chat/model/useChat.ts",
        "Verify useChat composable is exported",
        "Verify it uses both useChatStore and useWebRTC internally",
        "Verify startChat(email) function initiates invitation flow",
        "Verify acceptChat(invitationId) function handles accepting invite",
        "Verify sendMessage(text) function sends through WebRTC",
        "Verify messages reactive ref contains chat history",
        "Verify connectionStatus reflects current WebRTC state",
        "Open client/features/chat/index.ts",
        "Verify useChat is exported from feature index"
      ],
      "passes": false
    },
    {
      "name": "chat-widget-ui",
      "description": "## Chat Widget UI Component\n\nCreate the floating chat widget for the bottom-right corner.\n\n### Layout\n- Floating button in bottom-right corner (when chat closed)\n- Chat panel that slides up when opened\n- Header with peer email and close button\n- Messages area with scrollable history\n- Text input and send button at bottom\n- 'Join Room' button when not connected\n\n### States\n- Closed: Just floating button visible\n- Open + Disconnected: Shows 'Join Room' button and email input\n- Open + Connecting: Shows 'Connecting...' status\n- Open + Connected: Shows message list and input\n\n### Implementation Notes\n- Add new widget `client/widgets/chat/ui/ChatWidget.vue`\n- Use existing Tailwind patterns for styling\n- Position fixed, bottom-right\n- Add to widgets index.ts",
      "category": "ui",
      "steps": [
        "Start the development server with npm run dev",
        "Log in to the application",
        "Verify floating chat button appears in bottom-right corner",
        "Click the chat button",
        "Verify chat panel opens/slides up",
        "Verify 'Join Room' button is visible when not connected",
        "Verify email input field is present",
        "Enter an email address and click 'Join Room'",
        "Verify 'Connecting...' status appears",
        "Verify close button closes the chat panel"
      ],
      "passes": false
    },
    {
      "name": "chat-invitation-notification",
      "description": "## Chat Invitation Notification UI\n\nCreate notification component for incoming chat invitations.\n\n### Features\n- Poll for pending invitations periodically\n- Show notification badge on chat button when invites pending\n- Display invitation details (sender email)\n- Accept/Reject buttons\n- Notification toast or inline display\n\n### Implementation Notes\n- Add notification display to ChatWidget component\n- Poll every 5-10 seconds when user is authenticated\n- Show sender email in invitation notification\n- Accepting starts the P2P connection flow",
      "category": "ui",
      "steps": [
        "Start the development server with npm run dev",
        "Log in as user1 in browser 1",
        "Log in as user2 in browser 2 (incognito or different browser)",
        "In browser 1, open chat and send invitation to user2's email",
        "In browser 2, wait up to 10 seconds",
        "Verify notification badge appears on chat button in browser 2",
        "Open chat in browser 2",
        "Verify invitation from user1 is displayed with their email",
        "Verify Accept and Reject buttons are present",
        "Click Accept button",
        "Verify connection process begins"
      ],
      "passes": false
    },
    {
      "name": "chat-message-list",
      "description": "## Chat Message List Component\n\nCreate message display component with proper styling.\n\n### Features\n- Display messages with sender identification (You/Them)\n- Auto-scroll to bottom on new messages\n- Timestamp display\n- Different styling for sent vs received messages\n- Empty state when no messages\n\n### Implementation Notes\n- Add `client/widgets/chat/ui/ChatMessageList.vue`\n- Messages from current user on right (primary color)\n- Messages from peer on left (surface color)\n- Use existing Tailwind color patterns",
      "category": "ui",
      "steps": [
        "Establish P2P connection between two users",
        "In browser 1, type a message and send",
        "Verify message appears on right side in browser 1 with 'You' indicator",
        "In browser 2, verify message appears on left side",
        "In browser 2, type and send a reply",
        "Verify reply appears on right side in browser 2",
        "Verify reply appears on left side in browser 1",
        "Verify messages auto-scroll to show newest message",
        "Verify timestamps are displayed on messages"
      ],
      "passes": false
    },
    {
      "name": "chat-input-component",
      "description": "## Chat Input Component\n\nCreate text input component for sending messages.\n\n### Features\n- Text input field with placeholder\n- Send button\n- Enter key to send\n- Disabled state when not connected\n- Clear input after sending\n\n### Implementation Notes\n- Add `client/widgets/chat/ui/ChatInput.vue`\n- Emit message event to parent\n- Use existing BaseButton styling or custom",
      "category": "ui",
      "steps": [
        "Establish P2P connection between two users",
        "Verify text input is enabled after connection",
        "Type a message in the input field",
        "Press Enter key",
        "Verify message is sent and input is cleared",
        "Type another message",
        "Click the Send button",
        "Verify message is sent and input is cleared",
        "Disconnect the chat",
        "Verify input field is disabled when not connected"
      ],
      "passes": false
    },
    {
      "name": "layout-integration",
      "description": "## Integrate Chat Widget into Layout\n\nAdd the chat widget to the default layout so it appears on all authenticated pages.\n\n### Requirements\n- ChatWidget visible only when user is authenticated\n- Positioned fixed in bottom-right corner\n- Does not interfere with other UI elements\n- Persists across page navigation\n\n### Implementation Notes\n- Edit `client/app/layouts/default.vue`\n- Import and add ChatWidget component\n- Conditionally render based on authentication state\n- Ensure proper z-index layering",
      "category": "integration",
      "steps": [
        "Start the development server with npm run dev",
        "Navigate to login page without logging in",
        "Verify chat button is NOT visible",
        "Log in to the application",
        "Verify chat button appears in bottom-right corner",
        "Navigate to different pages in the app",
        "Verify chat button remains visible on all pages",
        "Open the chat widget",
        "Navigate to another page",
        "Verify chat remains open during navigation",
        "Log out",
        "Verify chat button disappears"
      ],
      "passes": false
    },
    {
      "name": "connection-status-ui",
      "description": "## Connection Status Display\n\nCreate visual feedback for WebRTC connection status.\n\n### States to Display\n- Disconnected: 'Join Room' prompt\n- Connecting: 'Connecting to [email]...' with spinner\n- Connected: Green indicator + peer email\n- Error: Error message with retry option\n\n### Implementation Notes\n- Add status display to ChatWidget header area\n- Use appropriate icons/colors for each state\n- Show peer email when connected",
      "category": "ui",
      "steps": [
        "Start the development server with npm run dev",
        "Log in and open chat widget",
        "Verify 'Disconnected' or 'Join Room' state is shown",
        "Enter peer email and click Join Room",
        "Verify 'Connecting...' status with spinner appears",
        "Verify peer email is shown in connecting message",
        "After connection established, verify green indicator appears",
        "Verify connected peer email is displayed in header",
        "If connection fails, verify error message appears",
        "Verify retry option is available on error"
      ],
      "passes": false
    },
    {
      "name": "signaling-polling",
      "description": "## Signaling Polling Implementation\n\nImplement polling mechanism for WebRTC signaling data exchange.\n\n### Flow\n1. User1 creates offer, stores in DB via API\n2. User2 polls for offer, receives it\n3. User2 creates answer, stores in DB\n4. User1 polls for answer, receives it\n5. Both poll for ICE candidates\n\n### Implementation Notes\n- Polling interval: 1-2 seconds during connection\n- Stop polling once connected\n- Timeout after reasonable period (30-60 seconds)\n- Clean up signaling data after connection established",
      "category": "integration",
      "steps": [
        "Open browser DevTools Network tab",
        "Start chat connection as user1",
        "Verify POST /api/chat/signal is called with offer",
        "Observe GET /api/chat/signal/[id] polling requests",
        "Accept invitation as user2 in second browser",
        "Verify user2 receives the offer",
        "Verify POST /api/chat/signal is called with answer from user2",
        "Verify user1 receives the answer",
        "Verify polling stops after WebRTC connection established",
        "Verify connection succeeds end-to-end"
      ],
      "passes": false
    },
    {
      "name": "disconnect-cleanup",
      "description": "## Disconnect and Cleanup\n\nImplement proper disconnection handling and resource cleanup.\n\n### Features\n- Disconnect button in connected state\n- Clean up RTCPeerConnection on disconnect\n- Clear messages on disconnect\n- Reset UI to disconnected state\n- Handle browser close/navigation\n- Handle peer disconnect gracefully\n\n### Implementation Notes\n- Add disconnect action to useChat composable\n- Listen for RTCPeerConnection close events\n- Use beforeunload event for browser close\n- Update connection status on peer disconnect",
      "category": "integration",
      "steps": [
        "Establish P2P connection between two users",
        "Verify both users see connected status",
        "In browser 1, click Disconnect button",
        "Verify browser 1 returns to disconnected state",
        "Verify browser 2 detects disconnection and updates UI",
        "Reconnect the two users",
        "Close browser 1 tab completely",
        "Verify browser 2 detects disconnection gracefully",
        "Verify no errors in console after disconnect",
        "Verify chat can be restarted after disconnect"
      ],
      "passes": false
    }
  ]
}
